# Stammdatenverwaltung - AI Coding Agent Instructions

## Problem-Solving Approach

When given a task without explicit implementation steps:
1. **Analyze first** - Break down the requirement into concrete sub-tasks
2. **Plan the approach** - Identify which files/components need changes
3. **Keep it simple** - Favor straightforward solutions over complex abstractions
4. **CLEAN code focus** - Prioritize readability, maintainability, and existing patterns
5. **Ask if unclear** - Request clarification on ambiguous requirements before implementing

## Project Overview
Spring Boot 3.5.6 master data management microservice using Java 21, JPA/Hibernate, and Flyway migrations. Manages person hierarchy (Students, Employees, Lecturers) with profile-based configuration for dev/test/prod environments.

## Architecture Essentials

### Entity Design: Joined Table Inheritance
- Base `Person` entity (`persons` table) with shared attributes (DOB, address, phone, photo)
- Specialized tables (`students`, `employees`, `lecturers`) join via `person_id` FK
- **Critical**: Person IDs must align with Team 10's database for cross-team collaboration
- Use `@SuperBuilder` and `@Data` from Lombok for entity hierarchy
- Example: `src/main/java/com/ase/stammdatenverwaltung/entities/Person.java`

### Database Strategy
- **Dev/Test**: H2 with PostgreSQL compatibility mode (`MODE=PostgreSQL;DATABASE_TO_LOWER=TRUE`)
- **Prod**: PostgreSQL
- **Schema management**: Flyway migrations ONLY (`hibernate.ddl-auto: validate`)
- All schema changes require versioned migration files in `src/main/resources/db/migration/`
- H2 file DB persists in `./data/devdb.mv.db` during development

### Security Architecture
Profile-based dual authentication:
- **Dev profile**: Basic Auth (in-memory users) + JWT (Keycloak) for flexibility
  - Public: Swagger, H2 console, `/actuator/**`, `/api/v1/public/**`
  - Secured: All other `/api/**` endpoints
  - Test users: `dev-user`/`dev-password` (ROLE_USER), `dev-admin`/`dev-password` (ROLE_ADMIN)
- **Prod profile**: JWT-only via Keycloak OAuth2 Resource Server
  - Public: `/actuator/health`, `/api/v1/public/**`
  - All other `/api/**` require valid Bearer token
- Custom `JwtAuthConverter` extracts roles from Keycloak `realm_access.roles` claim
- See `SecurityConfig.java` for profile-specific filter chains

## Developer Workflows

### Running the Application
```bash
# Development (default - no setup needed)
./mvnw spring-boot:run

# Production (requires PostgreSQL + Keycloak env vars)
export SPRING_PROFILES_ACTIVE=prod DATABASE_URL=jdbc:postgresql://... KEYCLOAK_ISSUER_URI=...
./mvnw spring-boot:run
```

### Code Quality (Required Before Commits)
```bash
./format-code.cmd      # Windows: Auto-format + logic checks
./format-code.sh       # Linux/Mac: Auto-format + logic checks
```
- **Spotless**: Auto-applies Google Java Format (2-space indent)
- **Checkstyle**: Logic-only rules (no formatting overlap)
- Build fails on Spotless violations; Checkstyle warnings don't block

### Database Migrations
1. Create versioned file: `V{version}__Description.sql` (e.g., `V3__Add_user_roles.sql`)
2. Use H2-compatible PostgreSQL syntax (avoid `SERIAL`, use `GENERATED BY DEFAULT AS IDENTITY`)
3. Test in dev first: `./mvnw spring-boot:run` (auto-applies on startup)
4. Verify with H2 console: http://localhost:8080/h2-console (JDBC: `jdbc:h2:file:./data/devdb`)

### Testing
```bash
./mvnw test           # Run all tests (H2 in-memory DB)
```
- Test profile uses separate H2 in-memory DB with PostgreSQL compatibility
- Service layer tests validate business logic and age constraints (MAX_AGE_YEARS = 150)

## Project-Specific Conventions

### Service Layer Pattern
- Annotate with `@Service`, `@Transactional`, `@Validated`, `@RequiredArgsConstructor`, `@Slf4j`
- Use constructor injection (Lombok's `@RequiredArgsConstructor` with `final` fields)
- Validate inputs with `@Valid` and throw `EntityNotFoundException` for missing entities
- Example: `PersonService.java` - read-only methods use `@Transactional(readOnly = true)`

### Controller Pattern
- Use `@RestController`, `@RequestMapping`, `@Tag` (OpenAPI), `@RequiredArgsConstructor`
- Leverage `@PreAuthorize("hasRole('...')")` for method-level security
- Return `ResponseEntity<>` with appropriate HTTP status codes
- Document with `@Operation`, `@ApiResponse` annotations for Swagger UI
- Example: `AuthTestController.java` demonstrates JWT claims extraction

### Validation Constants
- Define age/semester limits in service layer (e.g., `MAX_AGE_YEARS = 150` in `PersonService`)
- **Must match** DB constraints (must be compatible with H2 and PostgreSQL syntax)
- Document this alignment in SQL migration comments

### OpenAPI Configuration
- Global security scheme configured in `OpenApiConfig.java`
- JWT Bearer token added via `@SecurityRequirement(name = "bearerAuth")` on secured endpoints
- Test with Swagger UI: http://localhost:8080/swagger-ui.html (public in dev)

## Key Files Reference
- `SecurityConfig.java` - Profile-specific security filter chains
- `application-{profile}.yaml` - Environment-specific config (DB, logging, security)
- `pom.xml` - Java 21, Spring Boot 3.5.6, Flyway, PostgreSQL/H2 drivers
- `PROFILE_SETUP.md`, `DATABASE_MANAGEMENT.md`, `FORMATTING_SETUP.md` - Detailed guides

## Common Pitfalls
- Don't use `hibernate.ddl-auto: update` - always create Flyway migrations
- Profile activation: Set `SPRING_PROFILES_ACTIVE` env var, not `-Dspring.profiles.active`
- Keycloak JWT: Roles must be in "groups" claim (not "realm_access.roles")
- Spotless failures block build - run `./format-code.cmd` before pushing
